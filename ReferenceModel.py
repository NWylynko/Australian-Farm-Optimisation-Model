from pyomo.core import *
import random
import networkx

#
# Model
#

model = ConcreteModel()

#
# Parameters
#

model.CROPS = Set(initialize=['WHEAT','CORN','SUGAR_BEETS'])

model.TOTAL_ACREAGE = 500.0

model.PriceQuota = {'WHEAT': 100000.0,'CORN': 100000.0,'SUGAR_BEETS': 6000.0}

model.SubQuotaSellingPrice = {'WHEAT': 170.0,'CORN': 150.0,'SUGAR_BEETS': 36.0}

model.SuperQuotaSellingPrice = {'WHEAT': 0.0,'CORN': 0.0,'SUGAR_BEETS': 10.0}

model.CattleFeedRequirement = {'WHEAT': 200.0,'CORN': 240.0,'SUGAR_BEETS': 0.0}

model.PurchasePrice = {'WHEAT': 238.0,'CORN': 210.0,'SUGAR_BEETS': 100000.0}

model.PlantingCostPerAcre = {'WHEAT': 150.0,'CORN': 230.0,'SUGAR_BEETS': 260.0}

model.Yield = Param(model.CROPS,within=NonNegativeReals,initialize={'WHEAT':2.0,'CORN':2.4,'SUGAR_BEETS':16.0},mutable=False) #can initilise with std param data. Then adjust in the tree function

# stages=['Scenario1','Scenario2','Scenario3'] #must be titled ScenarioX when using CreateConcreteTwoStageScenarioTreeModel func
# model.stages = Set(initialize=stages)
# # Yield = {}
# Yield = {
#     ('Scenario1','WHEAT'):2.0,('Scenario1','CORN'):2.4,('Scenario1','SUGAR_BEETS'):16.0,
#     ('Scenario2','WHEAT'):2.5,('Scenario2','CORN'):3.0,('Scenario2','SUGAR_BEETS'):20.0,
#     ('Scenario3','WHEAT'):3.0,('Scenario3','CORN'):3.6,('Scenario3','SUGAR_BEETS'):24.0}
# model.Yield = Param(model.stages,model.CROPS,initialize=Yield,mutable=False)


#
# Variables
#

model.DevotedAcreage = Var(model.CROPS,bounds=(0.0,model.TOTAL_ACREAGE))

model.QuantitySubQuotaSold = Var(model.CROPS,bounds=(0.0,None))
model.QuantitySuperQuotaSold = Var(model.CROPS,bounds=(0.0,None))
model.QuantityPurchased = Var(model.CROPS,bounds=(0.0,None))


#
# Constraints
#

def ConstrainTotalAcreage_rule(model):
    return sum_product(model.DevotedAcreage) <= model.TOTAL_ACREAGE


model.ConstrainTotalAcreage = Constraint(rule=ConstrainTotalAcreage_rule)


def EnforceCattleFeedRequirement_rule(model,i):
    return model.CattleFeedRequirement[i] <= (model.Yield[i] * model.DevotedAcreage[i]) + model.QuantityPurchased[i] - \
           model.QuantitySubQuotaSold[i] - model.QuantitySuperQuotaSold[i]


model.EnforceCattleFeedRequirement = Constraint(model.CROPS,rule=EnforceCattleFeedRequirement_rule)


def LimitAmountSold_rule(model,i):
    return model.QuantitySubQuotaSold[i] + model.QuantitySuperQuotaSold[i] - (
                model.Yield[i] * model.DevotedAcreage[i]) <= 0.0


model.LimitAmountSold = Constraint(model.CROPS,rule=LimitAmountSold_rule)


def EnforceQuotas_rule(model,i):
    return (0.0,model.QuantitySubQuotaSold[i],model.PriceQuota[i])


model.EnforceQuotas = Constraint(model.CROPS,rule=EnforceQuotas_rule)


#
# Stage-specific cost computations
#

# def ComputeFirstStageCost_rule(model):
#     expr = sum(model.PlantingCostPerAcre[i]*model.DevotedAcreage[i] for i in ['WHEAT','SUGAR_BEETS'])
#     return expr
# model.FirstStageCost = Expression(rule=ComputeFirstStageCost_rule)
# model.FirstStageCost.pprint()#
def ComputeFirstStageCost_rule(model):
    expr = 0#sum(0*model.DevotedAcreage[i] for i in ['WHEAT','SUGAR_BEETS'])
    return expr
model.FirstStageCost = Expression(rule=ComputeFirstStageCost_rule)
model.FirstStageCost.pprint()#



def ComputeSecondStageCost_rule(model):
    expr = sum(model.PlantingCostPerAcre[i]*model.DevotedAcreage[i] for i in ['CORN','WHEAT','SUGAR_BEETS']) #moved this into stage2 and it still works. This is more consistent with AFO
    expr += sum_product(model.PurchasePrice,model.QuantityPurchased)
    expr -= sum_product(model.SubQuotaSellingPrice,model.QuantitySubQuotaSold)
    expr -= sum_product(model.SuperQuotaSellingPrice,model.QuantitySuperQuotaSold)
    return expr


model.SecondStageCost = Expression(rule=ComputeSecondStageCost_rule)


#
# PySP Auto-generated Objective
#
# minimize: sum of StageCosts
#
# An active scenario objective equivalent to that generated by PySP is
# included here for informational purposes.
def total_cost_rule(model):
    return  model.SecondStageCost  #model.FirstStageCost +

model.Total_Cost_Objective = Objective(rule=total_cost_rule,sense=minimize)


#
# Stochastic Data
#
stages=['BelowAverageScenario','AverageScenario','AboveAverageScenario'] #must be titled ScenarioX when using CreateConcreteTwoStageScenarioTreeModel func
Yield = {}
Yield['BelowAverageScenario'] = \
    {'WHEAT':2.0,'CORN':2.4,'SUGAR_BEETS':16.0}
Yield['AverageScenario'] = \
    {'WHEAT':2.5,'CORN':3.0,'SUGAR_BEETS':20.0}
Yield['AboveAverageScenario'] = \
    {'WHEAT':3.0,'CORN':3.6,'SUGAR_BEETS':24.0}

##access duals
model.dual = Suffix(direction=Suffix.IMPORT)

def pysp_scenario_tree_model_callback():
    # Return a NetworkX scenario tree.
    g = networkx.DiGraph()

    ce1 = 'FirstStageCost'
    g.add_node("Root",
               cost = ce1,
               variables = ["DevotedAcreage[*]"],
               derived_variables = [])

    ce2 = 'SecondStageCost'
    g.add_node("BelowAverageScenario",
               cost = ce2,
               variables = ["QuantitySubQuotaSold[*]",
                            "QuantitySuperQuotaSold[*]",
                            "QuantityPurchased[*]"],
               derived_variables = [])
    g.add_edge("Root", "BelowAverageScenario", weight=0.3333)

    g.add_node("AverageScenario",
               cost = ce2,
               variables = ["QuantitySubQuotaSold[*]",
                            "QuantitySuperQuotaSold[*]",
                            "QuantityPurchased[*]"],
               derived_variables = [])
    g.add_edge("Root", "AverageScenario", weight=0.3333)

    g.add_node("AboveAverageScenario",
               cost = ce2,
               variables = ["QuantitySubQuotaSold[*]",
                            "QuantitySuperQuotaSold[*]",
                            "QuantityPurchased[*]"],
               derived_variables = [])
    g.add_edge("Root", "AboveAverageScenario", weight=0.3334)

    return g

def pysp_instance_creation_callback(scenario_name,node_names):
    instance = model.clone()
    instance.Yield.store_values(Yield[scenario_name])
    return instance



