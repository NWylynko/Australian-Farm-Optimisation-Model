"""
author: young

This module generate the rotation info and writes it to excel.
This is because it is a bit slow and only need to be recalculated
when rotation rules are changed or new land uses are added.

There are three options
   1. Generate a large list of rotations using RotGeneration.py. The rotation generator generates all rotation options
      as default. This results in slow model execution time due to relatively long Pyomo matrix construction time.
      However the user has the ability to remove certain landuses before generating the array of phases (e.g. tedera
      and lucerne can be removed). Simulation modelling is used to generate the inputs.
   2. Generate a ‘custom’ list of rotations using RotGeneration.py. The user can specify the rotations they want
      generated by populating the ds_user_rot_init array and, at the top of the module, turn the boolean setting
      called cutomised_rotations to True and re-run the module. Simulation modelling is used to generate the inputs for these rotations.
   3. Generate a custom list of rotations and their inputs. The user can input the phases and their respective
      yield, chem and fert requirements into property.xlsx. RotGeneration.py is still required to be executed because
      it generates the coefficients for each rotation activity for the rotation constraints.


"""
import numpy as np
import pandas as pd
import itertools
from openpyxl import load_workbook

#AFO modules
import Functions as fun
import StructuralInputs as sinp
import PropertyInputs as pinp

##if you want to use a customised list of rotations this can be set to false - populate the array further down the module.
customised_rotations = False

if __name__ == '__main__': #use this so that sphinx doesnt run all the code when generating the docs
    yr0 = np.array(['b', 'h', 'o','of', 'w', 'f', 'l', 'z','r'
                   , 'a', 'ar'
                   , 's', 'sr'
                   , 'm'#])
                    , 'u', 'ur'
                    , 'x', 'xr'
                    , 'j', 't', 'jr', 'tr'])
    yr1 = np.array(['AR', 'SR'
           ,'E1', 'N', 'P', 'OF'
           , 'A'
           , 'S'
           , 'M'#])
            , 'U'
            , 'X'
            , 'T', 'J'])
    yr2 = np.array(['E', 'N', 'P'
           , 'A'
           , 'S'
           , 'M'#])
            , 'U'
            , 'X'
            , 'T', 'J'])
    yr3 = np.array(['E', 'N', 'P'
           , 'A'#])
            , 'U'
            , 'T'])
    yr4 = np.array(['A','Y'#])
            , 'U'
            , 'T'])
    yr5 = np.array(['A','Y'#])
            , 'U'
            , 'T'])

    arrays=[yr5,yr4,yr3,yr2,yr1,yr0]
    phases=fun.cartesian_product_simple_transpose(arrays)





    ###########################################################
    #params used to try make the rules more flexible to change#
    ###########################################################

    ##after how many yrs is annual resown
    resow_a = 4
    a_sow_col=np.size(phases,1)-1-resow_a #difference between history len and resow len -the col of the last phase yr that determines resseding (if 0 it means that all the history must be a crop for pasture to be resown)

    '''
    To understand this you must know the following;
    true&false = false
    true+false = true
    true*true*false = false
    '''


    for i in range(np.size(phases,1)-1):
    ##drop rules 1; unprofitable
        ###no cont canola
        phases = phases[~(np.isin(phases[:,i], ['N'])&np.isin(phases[:,i+1], ['N','r','z']))]
        ###no cont pulse
        phases = phases[~(np.isin(phases[:,i], ['P'])&np.isin(phases[:,i+1], ['P','l','f']))]
        ###no pulse after pasture
        phases = phases[~(np.isin(phases[:,i], ['AR', 'SR','A','M','S','U','X','T','J'])&np.isin(phases[:,i+1], ['P','l','f']))]
        ###no pasture after spraytoped
        phases = phases[~(np.isin(phases[:,i], ['S','SR'])&np.isin(phases[:,i+1], ['AR', 'SR','A', 'M','S','a','ar','s','sr','m']))]
        ###only spraytopped pasture after manipulated
        phases = phases[~(np.isin(phases[:,i], ['M'])&np.isin(phases[:,i+1], ['AR', 'A', 'M','a','ar','m']))]
        ###not going to resown tedera after a tedera (in a cont rotation you resow every 10yrs but that is accounted for with 'tc')
        phases = phases[~(np.isin(phases[:,i], ['T','J'])&np.isin(phases[:,i+1], ['tr','jr']))]
        ###not going to resow lucerne after a lucerne (in a cont rotation you resow every 5yrs but that is accounted for with 'uc' & 'xc')
        phases = phases[~(np.isin(phases[:,i], ['U','X'])&np.isin(phases[:,i+1], ['xr','ur']))]
        ###can't have 1yr of perennial unless it is the earliest yr in the history
        if i == 0:
            pass #first yr of rotation can be a perennial because
        else:
            try: #used for conditions that are concerned with more than two yrs
                phases = phases[~(np.isin(phases[:,i], ['T','J'])&~(np.isin(phases[:,i-1], ['T','J', 'Y']) + np.isin(phases[:,i+1], ['T','J','t','j'])))]
            except IndexError: pass
            ###can't have 1yr of perennial
            try: #used for conditions that are concerned with more than two yrs
                phases = phases[~(np.isin(phases[:,i], ['U','X'])&~(np.isin(phases[:,i-1], ['U','X', 'Y']) + np.isin(phases[:,i+1], ['U','X','u','x'])))]
            except IndexError: pass

    ##lucerne and tedera resowing
    phases = phases[~(~np.isin(phases[:,np.size(phases,1)-2], ['U','X'])&np.isin(phases[:,np.size(phases,1)-1], ['U','X','u','x']))] #lucerne after a non lucern must be resown
    phases = phases[~(~np.isin(phases[:,np.size(phases,1)-2], ['T','J'])&np.isin(phases[:,np.size(phases,1)-1], ['T','J','t','j']))] #Tedera after a non tedera must be resown

    ##annual resowing
    resow_cols = 2 #the number of cols where resowing can occur ie in yr0 and 1
    for i in range(resow_cols):
        i+=1
        ###if there is a previous annual then yr0 doesn't need to be resown
        ###if there is a previous annual then yr1 doesn't need to be resown
        a_index =np.any(np.isin(phases[:,np.size(phases,1)-i-resow_a:np.size(phases,1)-i], ['AR', 'SR','A','M','S']), axis=1)&np.isin(phases[:,np.size(phases,1)-i], ['ar', 'sr','AR', 'SR'])
        phases = phases[~a_index]
        ###if there are not annuals in the history then an annual in yr0 or yr1 must be resown
        a_index2 = np.all(~np.isin(phases[:,np.size(phases,1)-i-resow_a:np.size(phases,1)-i], ['AR', 'SR','A','M','S']), axis=1)&np.isin(phases[:,np.size(phases,1)-i], ['a', 's','m','A','M','S'])
        phases = phases[~a_index2]


    ##X can't be in the same rotation as U, T, J and A
    a_xutj = np.any(np.isin(phases[:,:], ['AR', 'SR','ar','a','A','m','M','s','sr','S']), axis=1)&np.any(np.isin(phases[:,:], ['X','x','xr','U','u','ur','T','t','tr','J','j','jr']), axis=1)
    x_utj = np.any(np.isin(phases[:,:], ['X','x','xr']), axis=1)&np.any(np.isin(phases[:,:], ['U','u','ur','T','t','tr','J','j','jr']), axis=1)
    u_tj = np.any(np.isin(phases[:,:], ['U','u','ur']), axis=1)&np.any(np.isin(phases[:,:], ['T','t','tr','J','j','jr']), axis=1)
    t_j = np.any(np.isin(phases[:,:], ['T','t','tr']), axis=1)&np.any(np.isin(phases[:,:], ['J','j','jr']), axis=1)
    phases = phases[~(a_xutj + x_utj + u_tj + t_j)]


    ######################################################
    #delete cont rotations that require special handeling#
    ######################################################
    '''
    remove cont rotations before generilisation
    -remove rotations that can provide them selves
    -when generalising don't generalise yr1 
        - this will stop Y X X X3 x4 providing itself ie if you generalied yr1 to X then this rotation would provide itself'
    '''
    ##check if every phase in a rotation is either lucerne or Y
    xindex=np.all(np.isin(phases[:,:], ['X','x','U','u']), axis=1)
    phases = phases[~xindex]
    ##check if every phase in a rotation is either T or Y
    tindex=np.all(np.isin(phases[:,:], ['T','J','t','j']), axis=1)
    phases = phases[~tindex]


    ######################
    #simplified rotations#
    ######################
    '''
    There are two options for simplified rotations:
    1. enter them manually below (this can be good for testing purposes)
    2. enter them in property.xl in the crop sheet (this is the more common option)
    
    '''

    ##option 1: enter the rotaions you want represented in the model
    ###This bit of code can be used to extract custom rotations only.
    ###You can alter the user_rot array to include to rotations you want to include (all other rotations will be excluded)
    ###The sequence of the rotation is irrelevant ie b b w w is the same as w b b w.
    ds_user_rot_init = np.array([['ar', 'a', 'w', 'w', 'r', 'b'] #todo should this become an input?
                                 ,['r', 'w', 'b', 'r', 'w', 'b']])

    if customised_rotations:
        ##roll the rotation to make all the phases required for a given rotation
        ds_user_rot=ds_user_rot_init
        for offset in range(1,np.size(ds_user_rot_init,axis=1)):
            ds_user_rot = np.concatenate((ds_user_rot, np.roll(ds_user_rot_init, offset, axis=1)),axis=0)
        ##the next code simplifies the full list of phases to only include the necessary ones to represent the user rotations.
        ix_bool=np.zeros(len(phases))
        ###loop through all rotation phases then loop through all of the user rotations.
        ###this checks if the rotation phases are a superset of any of the user rotations
        for s_rot_phase, ix_phase in zip(phases,range(len(phases))):
            for s_user_rot in ds_user_rot:
                req=1
                for i in range(np.size(s_user_rot)):
                    req*=sinp.landuse[s_rot_phase[i]].issuperset({s_user_rot[i]})
                ix_bool[ix_phase]=max(req,ix_bool[ix_phase])
        phases=phases[ix_bool>0]


    ##option 2: if you want to represent the rotations from property.xlsx
    if pinp.crop['user_crop_rot']:
        phases =pinp.crop['fixed_rotphases'].reset_index().values.astype('str')

    ##################
    #continuous phase#
    ##################
    ##only generate cont phases if there are other phases that contain a resown version of the landuse and a normal version of the landuse because the inputs for the cont phases are generated from a combo of resown and normal phases
    if np.isin(phases,'tr').any() and np.isin(phases,'t').any():
        tc=np.array(['tc','tc','tc','tc','tc','tc'])
        phases = np.concatenate((phases, [tc])) #square brackets required because otherwise it thinks that the cont rotations are just 1D
    if np.isin(phases,'jr').any() and np.isin(phases,'j').any():
        jc=np.array(['jc','jc','jc','jc','jc','jc'])
        phases = np.concatenate((phases, [jc])) #square brackets required because otherwise it thinks that the cont rotations are just 1D
    if np.isin(phases,'ur').any() and np.isin(phases,'u').any():
        uc=np.array(['uc','uc','uc','uc','uc','uc'])
        phases = np.concatenate((phases, [uc])) #square brackets required because otherwise it thinks that the cont rotations are just 1D
    if np.isin(phases,'xr').any() and np.isin(phases,'x').any():
        xc=np.array(['xc','xc','xc','xc','xc','xc'])
        phases = np.concatenate((phases, [xc])) #square brackets required because otherwise it thinks that the cont rotations are just 1D

    ############################################################################################################################################################################################
    ############################################################################################################################################################################################
    #Generate the paramater for rotation provide and require
    ############################################################################################################################################################################################
    ############################################################################################################################################################################################


    ##history require
    rot_hist = phases[:,0:np.size(phases,1)-1]
    rot_hist = np.unique(rot_hist, axis=0)


    ##generate a list of the phases and histories (agretated version)
    l_phases = [''.join(x) for x in phases.astype(str)]
    l_rot_hist = [''.join(x) for x in rot_hist.astype(str)]


    ##################
    #con 1 param     #
    ##################
    '''determines what history1 each rotation requires and provides'''
    mps_bool_req=[]
    mps_bool_prov=[]
    for rot_phase in phases:
        ##test variable just used to help check all rotations provide and require a history - only for user information.
        ##every rotation should provide and require a history.
        test=0
        test2=0
        for hist in rot_hist:
            rot_phase_req=[]
            rot_phase_prov=[]
            l_hist=[]
            for i in range(len(hist)):
                l_hist.append(sinp.landuse[hist[i]]) #deterimines the sets in each constraint
                rot_phase_req.append(sinp.landuse[rot_phase[i]]) #appends each set that corresponds to the letters in the rot_phase (required)
                rot_phase_prov.append(sinp.landuse[rot_phase[i+1]]) #appends each set that corresponds to the letters in the rot_phase (provides)
            req=1
            prov=-1
            for i in range(len(hist)):
                req*=l_hist[i].issuperset(rot_phase_req[i]) #checks each set in a given rotation for the req part of the equation
                prov*=l_hist[i].issuperset(rot_phase_prov[i]) #checks each set in a given rotation for the prov part of the equation
            test+=prov
            test2+=req
            # mps_bool.append(req+prov)
            mps_bool_req.append(req)
            mps_bool_prov.append(prov)
        if test==0: #doesn't provide a history
            print('rot doesnt provide a history: ',rot_phase)
        if test2==0: #doesn't require a history
            print('rot doesnt req a history: ',rot_phase)
    rot_phase_by_constrain = pd.DataFrame(list(itertools.product(l_phases,l_rot_hist) ) ) #had to use this cartesian method as i couldn't get the fast function to work
    mps_bool_req=pd.Series(mps_bool_req) #convert to series because easier to manipulate
    mps_bool_prov=pd.Series(mps_bool_prov) #convert to series because easier to manipulate
    mps_bool_req=pd.concat([rot_phase_by_constrain, mps_bool_req], axis=1) #add two dfs together
    mps_bool_prov=pd.concat([rot_phase_by_constrain, mps_bool_prov], axis=1) #add two dfs together
    mps_bool_req = mps_bool_req[(mps_bool_req.iloc[:,2] != 0)]
    mps_bool_prov = mps_bool_prov[(mps_bool_prov.iloc[:,2] != 0)]


    ############################################################################################################################################################################################
    ############################################################################################################################################################################################
    #Write rotations and rotation provide/require stuff to excel
    ############################################################################################################################################################################################
    ############################################################################################################################################################################################

    ##start writing
    writer = pd.ExcelWriter('Rotation.xlsx', engine='xlsxwriter')
    ##list of rotations - index: tuple, values: expanded version of rotation
    rot_phases =  pd.DataFrame(phases, index=l_phases)
    rot_phases.to_excel(writer, sheet_name='rotation list',index=True,header=False)
    ##con1 - the paramater for which history each rotation provides and requires
    mps_bool_req.to_excel(writer, sheet_name='rotation_req',index=False,header=False)
    mps_bool_prov.to_excel(writer, sheet_name='rotation_prov',index=False,header=False)
    ##con1 set - passed into the pyomo constraint
    rot_hist = pd.DataFrame(rot_hist, index=l_rot_hist)
    rot_hist.to_excel(writer, sheet_name='rotation con1 set',index=True,header=False)


    ##finish writing and save
    writer.save()




























